package ds

import (
	"math/rand"
	"sync"
	"testing"
	"time"
)

func get_insert_lambda(heap *Heap[int], wg *sync.WaitGroup) func(int) {
	return func(data int) {
		n := rand.Intn(1000)
    		time.Sleep(time.Duration(n)*time.Millisecond)
		heap.Push(data)
		wg.Done()
	}
}

func TestThreadedFullHeapWorkflow(t *testing.T) {
	input_heap := Heap[int]{}
	input_heap.custom_is_lower_fn = is_lower
	wg := sync.WaitGroup{}

	values := []int{
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
		1, 30, -1, 20, 25,
	}

	insert_lambda := get_insert_lambda(&input_heap, &wg)

	for _, value := range values {
		wg.Add(1)
		go insert_lambda(value)
	}

	wg.Wait()

	expected_array := []int{
		-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
		 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
		20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20, 
		25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25, 
		30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,
	}
	var current_element int

	for i := 0; i < 5; i++ {
		current_element = input_heap.Pop()
		if current_element != expected_array[i] {
			t.Errorf(
				"Pop_from_heap(&input_heap) = %d, expected %d",
				current_element, expected_array[i],
			)
		}
	}

}
